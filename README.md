# The Firmo protocol system

This document describes the Firmo protocol and its implementation. The
use of the protocol illustrated through examples of how derivative
contracts can be created using the protocol.

The Firmo protocol centers around a Domain Specific Language (DSL)
called eToroLang which is used to specify the derivative contracts.

Using a non turing complete DSL for thus purpose has several
advantages. In particular, the language is restricted such that using
it to specify unintended behavior is impossible. Further, as the
semantics of the language are formally verified, contracts specified
in the language is guaranteed to behave as intended and to only have a
single interpretation.

To show a possible integration of the language, we provide a graphical
frontend for creating, deploying and monitoring future
contracts. Behind the scenes, this frontend will generate
corresponding eToroLang code which is subsequently compiled to EVM and
deployed to a local Ethereum testnet. By generating eToroLang, we
ensure that the static guarantees of the language applies regardless
of frontend functionality. Additionally, the frontend makes it
possible view both the generated eToroLang code and the compiled EVM
code.

The frontend is for demonstration purposes only and relies on being
able to act as a signatory on behalf of the accounts representing both
parties agreeing to the contract. In an actual deployment of the
system, a separate signing step by each individual signatory is
required before they can enter into agreement. Further, the
demonstration fronted will always create a contractual agreement
between two predefined parties. Finally, The current implementation of the
on-chain contracts will take the amount of tokens held by the contract
into escrow. In an actual implementation of the system, an alternative
method would be used which avoids large amounts of tokens in this
manner.

## The eToroLang Language
We present a couple of examples which shows eToroLang in action.

### Binary Option, a Simple Bet
The simplest useful example is a binary option. Two parties are
involved in the contract, and the contract holds a specific amount of
tokens which either of the party will receive in full amount at the
maturity of the contract. This contract is equivalent to a simple bet
and the outcome will be determined by some kind of event whose result
is read from an oracle.

    scale(
        100,
        100,
            if obs(bool, addressDataFeedBool, 0) within minutes(2) then
                        transfer( addressErc20, B, A)
        else
    transfer( addressErc20, A, B))


Addresses are text strings written as `0x[0-9a-f]{40}`.

This contract will transfer 100 tokens to A if the oracle/data feed
shows the value true at any time within two minutes. If that does not
happen, 100 tokens are transferred to B. Both A and B need to put in
100 tokens for the contract to be considered activated. The amounts
are deposited through the function calls `approve` on the ERC20, and
`activate` on the contract generated by `etlc`.

This binary option could simply be referred to as a bet since that is
something everybody are familiar with.

In the presentation, the observable value can be presented as the
outcome of a sports event or something similar.

### European put option, an Insurance Against a Drop in the ETH price

Scenario: A owns 1 ETH and A would like an insurance of a drop in the
ETH price below 100 USD three months from now. So A would like a
contract whose value plus the value of an ether is at least 100
USD. This can be achieved by the following contract:

    translate(
      days(90),
      scale(
        100,
        max(0, 100 - obs(int, priceFeed, ETHUSD))
        transfer(eToroUSD, B, A )))

If the ETH price at the strike time is 10 USD, then this contract will
pay out 90 USD, thus guaranteeing A a value of 100 USD at the maturity
of the contract.


## Working with the system
We now describe how to set up the various components needed to get the
demonstration frontend up and running.

At a high level, the system is comprised of three main components.

### Frontend
Implements the web interface which is used for visualizing and
manipulating the contracts.

### Backend server
The backend server provides the data storage and compilation services
for the frontend.

### The compiler
Compiles the eToroLang source code to EVM binary code providing the
contract features described above.

### Dependencies
Before proceeding, make sure that you have the following installed

 * `git`
 * `yarn`
 * A browser with the [Metamask](http://metamask.io) extension installed

### Running and installing
In order to compile and run the demo client you need to go through the
following steps.

#### Starting the server
 1. Clone the etorolang-demo-server repository:  
    `git clone https://github.com/Firmo-Network/etorolang-demo-server`
 1. Change diretory:  
    `cd etorolang-demo-server`
 1. Install dependencies:  
    `yarn install`
 1. Start the server  
    `yarn start`

#### Starting the client
In a separate terminal window do:

 1. Clone the etorolang-demo-server repository:  
    `git clone https://github.com/Firmo-Network/etorolang-demo-client`
 1. Change diretory:  
    `cd etorolang-demo-client`
 1. Install dependencies:  
    `yarn install`
 1. Start the client (will launch a browser)  
    `yarn start`

Below is a screenshot of the started frontend

![Frontend screenshot](https://raw.githubusercontent.com/Firmo-Network/etlc/master/docs/frontend.png?token=AABFWOQJMDDFRAKTDADEXHC432VAC)

#### Setting up metamask

 1. Add and connect to a custom RPC endpoint with the address
    `http://127.0.0.1:8545`
 1. Import the accounts with the private keys  
    `ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f`
    and  
    `0dbbe8e4ae425a6d2687f1a7e3ba17bc98c673636790f1b8ad91193c05875ef1`
    into Metamask
 1. You are now able to create contracts using the interface.

Note that, since this is a demo only, all contracts are entered
between the two parties represented by the accounts belonging to the
private keys.

After a contract has expired, you will be able to see the change of
the balances of the two accounts according to the outcome of the
contract.
